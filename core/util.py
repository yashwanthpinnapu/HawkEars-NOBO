# Utility functions

import glob
import os
import re
from pathlib import Path
from posixpath import splitext
from types import SimpleNamespace
import zlib

import numpy as np

from core import cfg

AUDIO_EXTS = [
  '.3gp', '.3gpp', '.8svx', '.aa', '.aac', '.aax', '.act', '.aif', '.aiff', '.alac', '.amr', '.ape', '.au',
  '.awb', '.cda', '.dss', '.dvf', '.flac', '.gsm', '.iklax', '.ivs', '.m4a', '.m4b', '.m4p', '.mmf',
  '.mp3', '.mpc', '.mpga', '.msv', '.nmf', '.octet-stream', '.ogg', '.oga', '.mogg', '.opus', '.org',
  '.ra', '.rm', '.raw', '.rf64', '.sln', '.tta', '.voc', '.vox', '.wav', '.wma', '.wv', '.webm', '.x-m4a',
]

# compress a spectrogram in preparation for inserting into database
def compress_spectrogram(data):
    data = data * 255
    np_bytes = data.astype(np.uint8)
    bytes = np_bytes.tobytes()
    compressed = zlib.compress(bytes)
    return compressed

# decompress a spectrogram, then convert from bytes to floats and reshape it
def expand_spectrogram(spec, low_band=False):
    bytes = zlib.decompress(spec)
    spec = np.frombuffer(bytes, dtype=np.uint8) / 255
    spec = spec.astype(np.float32)

    if low_band:
        spec = spec.reshape(cfg.audio.low_band_spec_height, cfg.audio.spec_width, 1)
    else:
        spec = spec.reshape(cfg.audio.spec_height, cfg.audio.spec_width, 1)

    return spec

def format_elapsed_time(start_time, end_time):
    elapsed_time = end_time - start_time
    hours = int(elapsed_time // 3600)
    minutes = int((elapsed_time % 3600) // 60)
    seconds = int(elapsed_time % 60)
    return f"{hours:02}H:{minutes:02}M:{seconds:02}S"

# return list of audio files in the given directory;
# returned file names are fully qualified paths, unless short_names=True
def get_audio_files(path, short_names=False):
    files = []
    if os.path.isdir(path):
        for file_name in sorted(os.listdir(path)):
            file_path = os.path.join(path, file_name)
            if os.path.isfile(file_path):
                base, ext = os.path.splitext(file_path)
                if ext != None and len(ext) > 0 and ext.lower() in AUDIO_EXTS:
                    if short_names:
                        files.append(file_name)
                    else:
                        files.append(file_path)

    return sorted(files)

# return list of strings representing the lines in a text file,
# removing leading and trailing whitespace and ignoring blank lines
# and lines that start with #
def get_file_lines(path):
    try:
        with open(path, 'r') as file:
            lines = []
            for line in file.readlines():
                line = line.strip()
                if len(line) > 0 and line[0] != '#':
                    lines.append(line)

            return lines
    except IOError:
        print(f'Unable to open input file {path}')
        return []

# return a dictionary mapping class names to banding codes, based on the classes file;
# if reverse=True, map codes to class names
def get_class_dict(class_file_path=cfg.misc.classes_file, reverse=False):
    lines = get_file_lines(class_file_path)
    class_dict = {}
    for line in lines:
        tokens = line.split(',')
        if len(tokens) == 2:
            if reverse:
                class_dict[tokens[1]] = tokens[0]
            else:
                class_dict[tokens[0]] = tokens[1]

    return class_dict

# return a list of class names from the classes file
def get_class_list(class_file_path=cfg.misc.classes_file):
    lines = get_file_lines(class_file_path)
    class_list = []
    for line in lines:
        tokens = line.split(',')
        if len(tokens) == 2:
            class_list.append(tokens[0])

    return class_list

# return a source name given a file name
def get_source_name(filename):
    if filename is None or len(filename) == 0:
        return "Unknown"

    if '.' in filename:
        filename, _ = splitext(filename)

    for pattern, source in cfg.misc.source_regexes:
        if re.match(pattern, filename):
            return source

    return "Unknown"

# return the version number, as defined in HawkEars/version.txt
def get_version(file_path="version.txt"):
    if os.path.exists(file_path):
        lines = get_file_lines(file_path)
        if len(lines) > 0:
            return lines[0]

    return ""

# return True iff given path is an audio file
def is_audio_file(file_path):
    if os.path.isfile(file_path):
        base, ext = os.path.splitext(file_path)
        if ext != None and len(ext) > 0 and ext.lower() in AUDIO_EXTS:
            return True

    return False

# given a directory containing Audacity label files generated by HawkEars, BirdNET or Perch,
# return a list of label objects;
# if unmerge=True, split any merged labels;
# for testing though, it is much better to run inference with label merging disabled,
# so that individual label scores are retained
def labels_to_list(input_path, unmerge=True):
    if not os.path.exists(input_path):
        return None, False

    unmerged = False # return a flag indicating if any labels were split to undo merging
    regex = "(\\S+)\\s+(\\S+)\\s+(\\S+);(\\S+)*"
    label_list = []
    label_paths = glob.glob(os.path.join(input_path, "*.txt"))
    for label_path in label_paths:
        # get the file_prefix, i.e. stem minus suffix, which should match the recording name stem
        if label_path.endswith('_HawkEars.txt'):
            file_prefix = Path(label_path).name[0:-len('_HawkEars.txt')]
        elif label_path.endswith('.BirdNET.results.txt'):
            file_prefix = Path(label_path).name[0:-len('.BirdNET.results.txt')] # BirdNET
        elif label_path.endswith('_Perch.txt'):
            file_prefix = Path(label_path).name[0:-len('_Perch.txt')]
        else:
            continue # ignore this one

        lines = get_file_lines(label_path)
        for line in lines:
            result = re.split(regex, line)
            if len(result) != 6:
                continue

            start_offset = float(result[1])
            end_offset = float(result[2])
            species=result[3]
            score = float(result[4])
            label_list.append(SimpleNamespace(file_prefix=file_prefix, species=species, start=start_offset, end=end_offset, score=score))

            if unmerge:
                # if label duration is longer than cfg.audio.segment_len, split it up
                current = start_offset
                fuzz_factor = .00001 # fuzz factor for floating point compares
                while abs(end_offset - current - cfg.audio.segment_len) > fuzz_factor and current < end_offset:
                    unmerged = True
                    current += cfg.infer.spec_overlap_seconds
                    label_list.append(SimpleNamespace(file_prefix=file_prefix, species=species, start=current, end=current + cfg.audio.segment_len, score=score))

    return label_list, unmerged

# given a list of strings, replace all "special" quotes with "plain" quotes
def replace_special_quotes(input_list):
    special_quotes = "\"‘’“”"
    plain_quote = "'"
    translation_table = str.maketrans(special_quotes, plain_quote * len(special_quotes))
    output_list = []
    for item in input_list:
        output_list.append(item.translate(translation_table))

    return output_list
